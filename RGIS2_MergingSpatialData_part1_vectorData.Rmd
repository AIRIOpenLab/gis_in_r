---
title: "Merging Spatial Data"
output:
  html_document:
    toc: true
    toc_depth: 4
    theme: spacelab
    mathjax: default
    fig_width: 6
    fig_height: 6
---


```{r knitr_init, echo=FALSE, cache=FALSE, message=FALSE,results="hide"}
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)

library(rgdal)
library(sp)
library(rgeos)
library(plyr)
library(raster)

sf<-readOGR("RGIS2_Data",'sf_incomes')
sf.ft<-readOGR("RGIS2_Data",'sf_foodtrucks')
newcrs<-CRS(proj4string(sf))
sf.ft.newproj <- spTransform(sf.ft, newcrs)

```

***

When working with spatial data, one is rarely interested in working with only one source of data. This tutorial will introduce a set of tools for linking vector data with other data sources. It begins by introducing how to link spatial vector data with non-spatial data from in table format, then turns to the problem of linking multiple sources of spatial data through spatial joins and intersects. 

This tutorial uses the `sp`, `rgdal`, and `raster` libraries from the `RGIS1` tutorial. If you have not yet installed those, please revisit that tutorial for directions. In addition, this tutorial will also make use of the `rgeos` library, installation of which is discussed in `part0_setup`. 

***

# 1.Spatial* + Non-Spatial

An attribute join combines tabular data with a Spatial* object by associating each observation in a table with a GIS object (a polygon, line, or point). If you have done attribute joins of shapefiles in GIS software like _ArcGIS_ or _QGis_, or merged two datasets in _Stata_ or _R_, this process is analogous -- in an Attribute Join, a `Spatial*Dataframe` (be that a `SpatialPolygonsDataFrame`, `SpatialPointsDataFrame`, or `SpatialLinesDataFrame`) is merged with a table (an R dataframe) using a common _unique identifier_. 

Assume we have:

* a `SpatialPolygons` object named _worldCountries_, and
* a dataframe called _countryData_ with the attribute data to join

where:

* _"id-number"_ is the colum that contains the unique identifier in _worldCountries_, and 
* _"countryID"_ is the column that contains the unique identifier in _countryData_. 

Then we can just merge worldCountries@data with countryData on those variables, with one small nuance: **DO NOT MERGE YOUR DATA USING THE `merge` COMMAND!** 

The `merge` command that comes with R does not preserve the order of rows. Because R keeps track of which rows in the attribute table are associated with which `Spatial*` observations based on the order of observations, using the `merge` command can shuffle which information is associated with which Point/Line/Polygon.

Instead, use `join` from the `plyr` library. `join` guarantees that "Unlike merge, [`join`] preserves the order of x no matter what join type is used. If needed, rows from y will be added to the bottom. Join is often faster than merge, although it is somewhat less featureful - it currently offers no way to rename output or merge on different variables in the x and y data frames."

Since we always want to keep all the rows from our `Spatial*` data, we will use the following options:

```{r eval=FALSE, tidy=FALSE}
library(plyr)
worldCountries@data <- join(worldCountries@data, countryData, by = c("id-number" = "countryID"), type = "left")
```

(`type="left"` is the same as using the `all.x=TRUE` option for `merge`.)

That's it!

***

### Exercise 1

#. Download and unzip the `RGIS2_Data` folder. 

#. Load the CSV table `PhillyEducAttainment.csv` from the data loaded above into a dataframe in R and name it `education`.

#. Load the shapefile `PhillyTotalPopHHinc` from the folder `philly`. 

#. Check out the column names of `philly` and and of `education` to determine which one might contain the unique identifier for the join. Hint: use the `names()` command.

#. Join the `education` data frame with `philly` using `merge` as described above. Use the `names()` command to see if the join was successful.

#. Now we could plot one of the variables we just joined - but be aware that a choropleth map of the total number of the female population per census tract with a Bachelor's degree is rather meaningless. 

```{r eval=FALSE}
spplot (philly, "JN9E032")
```

***

# 2. Spatial* + Spatial*

Combining different Spatial* data sources is one of the most common things you will do in GIS research. Consider the following examples: 

* You have a SpatialPoints file of households in India, and a SpatialPolygons file of Indian state borders. How do you estimate the average income of households in each state? 
* You have a SpatialPoints file of government projects in the US and a SpatialPolygons file of electoral constituencies. Do elected officials with more projects in their district have higher rates of re-election?

Most of the time, you answer these questions using some form of Spatial Join. Unlike the "Attribute Joins" described above, a spatial join in your first purely spatial operation. In a spatial join, observations from different datasets are joined based not on a variable, but by their relationship in space.

## 2.1 Managing Coordinate Reference Systems (CRS)
To combine two Spatial* datasets, the first thing you have to do is make sure they have the same CRS. If you try and work with two Spatial* objects in R that are not in the same CRS, you *will* get results, but those results will be nonsense! **Note that this is very different from programs like ArcGIS that will take care of this problem for you!** So before we can join Spatial* objects, we need to learn to re-project different data sources into a common CRS. 

In `RGIS1`, we reviewed how to define a projection for a dataset. **Defining** a projection is when the user tells the computer how it should *interpret* the x-y coordinates associated with a `Spatial*` object. For example, if data comes from a GPS device, one must tell the computer those x-y coordinates are latitudes and longitudes.

Now we will discuss how to *re*-project Spatial Data. **Reprojecting** is when you tell the computer to *convert* a spatial object -- whose projection has already been defined! -- from its current projection into a new projection. 

Reprojecting vector data requires two tools, both in the `sp` package:

* a Coordinate Reference System `CRS` object with the new CRS you wish to apply
* the `spTransform()` function

As previously noted, a CRS object includes all the information needed to project a spatial object, generally including both a Geographic Coordinate System (the model of the Earth used to create the data) and a projection (a way of converting points on the three-dimensional Earth onto a two-dimensional plane).

The CRS() function has access to a large library of coordinate systems and transformations, so you just need to know the code for the CRS you want. Codes -- often called a "projection strings" -- can be found [online here](http://www.spatialreference.org).

Once you've found the projection you want, you can create the appropriate CRS object using one of two codes -- the `proj4` string, or the `EPSG` code. These are equivalent, but look a little different.  

For example, you can create a CRS object for [UTM zone 33N (EPSG:32633)](http://spatialreference.org/ref/epsg/wgs-84-utm-zone-33n/) by either passing the full proj4 code:

```{r eval=FALSE}
MyNewProjection <- CRS("+proj=utm +zone=33 +ellps=WGS84 +datum=WGS84 +units=m +no_defs")
```

or the EPSG code:

```{r eval=FALSE}
MyNewProjection <- CRS("+init=EPSG:32633")
```

Once you've defined a `CRS` object with the new CRS you want to use, all you have to do is execute the `spTransform` function on the object you want to re-project. If, for example, we have an object called MyCity and we want to reproject this into a new CRS called MyNewCRS, we would type:

```{r eval=FALSE}
MyNewCRS <- CRS("definition of projection goes here as string")
MyCity.reprojected <- spTransform(MyCity, MyNewCRS)
```

Note that you can also retrieve the CRS from an existing `Spatial*` object with the `proj4string()` command! So if you have two files -- `file.a` and `file.b` -- a common idiom for reprojecting `file.b` into the CRS of `file.a` is:

```{r, eval=FALSE}
common.crs <- CRS(proj4string(file.a))
file.b.reprojected <- spTransform(file.b, common.crs)
```


***

### Exercise 2

#. If you haven't already, create a directory `R_Workshop` on your Desktop and unzip `RGIS2_Data` into that folder. 

#. Load the `rgdal`, `sp`, and `dplyr` packages.

#. Read in the `sf_incomes` shapefile into R and name it `sf`. 

#. Read the `sf_foodtrucks` shapefile into R and name it `sf.ft`.

#. What is the CRS of `sf`?   What is the CRS of `sf.ft`?

#. Reproject `sf.ft` so it matches the projection of `sf` and assign it to a new object called `sf.ft.newproj`.

#. You can use the `range()` command from the R base package to compare the coordinates before and after repojection and confirm that you actually have transformed them. `range()` simply returns the _min_ and _max_ value of a vector of numbers that you give it. So you can check with:  
`range(coordinates(sf.ft))`  
and  
`range(coordinates(sf.ft.newproj))`  

#. You can also compare them visually with:  
```{r}
par(mfrow=c(1,2)) 
plot(sf.ft, axes=TRUE)
plot(sf.ft.newproj, axes=TRUE)
```


## 2.2. Simple Spatial Joins Using The `over` Command


They primary tool for doing spatial joins is the `over` command from the `sp` library. The exact behavior of `over` depends on the inputs being used, but the basic sytax is "For each item of first argument, give me information about the intersecting item of second argument".

For example, if I wanted to get information on the census tract of every food truck:

```{r}
truck.home.tract <- over(sf.ft.newproj,sf)
head(truck.home.tract)
```

Note that because `sf` is a `SpatialPolygonDataFrame`, `over` returned the relevant row of data for each point. If sf did not have any data, we would just get the index of the home polygon for each truck. We can see this behavior if we use the `geometry()` function to strip away the DataFrame:


```{r}
truck.home.tract.index <- over(sf.ft.newproj,geometry(sf))
head(truck.home.tract.index)
```


**Note that the one type of spatial join that `over` can't handle is between two `SpatialPolygon` objects.** To join two `SpatialPolygon` objects, we use the `gIntersect` tool from the `rgeos` library discussed below!

### Aggregating intersected items

One situation to be aware of is when each item in the first argument potentially intersects more than one item in the second argument. For example, if we asked "what food trucks are in each census tract?", there would obviously be many food trucks per tract. 

By default, when multiple items intersect an item in the first argument, `over` will just return the first one. However, if the second item has a DataFrame associated with it, it is possible to ask `over` to aggregate the multiple items. 

For example, if we add a column of 1s to our food truck data, then ask `over` to sum up that column, we get back the number of food trucks in each census tract. 

```{r}
sf.ft.newproj@data$counter<-1
num.food.trucks <- over(sf,sf.ft.newproj[,'counter'], fn=sum)
num.food.trucks$counter[is.na(num.food.trucks$counter)] <- 0  # fill in zeros.
head(num.food.trucks,12)
```

If we had other information on food trucks -- like their value -- we could also ask for things like their mean value by passing the `mean` function. 

The other option is to ask `over` to return all matching items by passing the argument `returnList=TRUE`. Instead of getting back a vector, you will get back a list, where each entry has all matching items for an input item. For example, here we can see that the 19th Census tract contains the food trucks with indexes 86, 89, 130, 295, etc.:

```{r}
over(sf,geometry(sf.ft.newproj),returnList=TRUE)[18:22]
```

## 2.3. Fancy Joins and Geometric Operations with `rgeos`

The `over` command will cover a remarkable number of situations, but it falls short in two areas. First, it only looks at whether things are at exact same point in space, and second, it can't merge two `SpatialPolygons` objects. 

When we want to do fancer geometric operations, we use the `rgeos` library. `rgeos` (which stands for "R interface to the *Geometry Engine - Open Source* library") is a set of tools for geometric operations. `GEOS` a huge library, and one that underlies many spatial tools (not just in R). Whenever you're thinking about a geometric operation, `rgeos` is the first place to look. Most commonly:

* If you have a SpatialPoints object and want to create a SpatialPolygon where each polygon contains all points within a given distance of a point, you can use the `gBuffer` tool.
* If you want to see if two SpatialPolygon's intersect, you can use the `gIntersects` tool. 

### Exercise 3

Our goal is to select all SF census tracts that fall within a range of 2 kilometers of Bi-Rite Ice Cream. 

> Think about this for a moment -- what might be the steps you'd follow?

Here is one, but not the only way to do this.

#. Get the polygons
#. Find the city center coordinates
#. Create a buffer around the center
#. Select all polys that fall in the buffer

Let's do it! 

#. Get the polygons.  
Got those.  
We will reuse `sf` for the census tract polygons.

#. Find the city center coordinates.  
Ok. I will tell you: Lat is 37.761518, and Lon is -122.425930. (There also is a convenient `geocode()` function in the `ggmap` package. We will deal with that package in the next section.)  
With this information, create a `SpatialPoints` object named `birite`.  

#. Create a buffer around the center.  
Here is where we will use the `gBuffer()` function from the `rgeos` package. The function can take a number of arguments, but for this purpose we will only need two: the __sp object__ and the __width__ of the buffer, which is assumed to be in map units. The function returns a `SpatialPolygons` object to you with the buffer - name it `birite.buf`.  
So your command would look something like  
```
birite.buf <- gBuffer(the_spatial_point_object, width = a_number_here)
```  
Now -- __before you create this buffer__, think about what you might need to do to `birite` before you proceed.

#. Select all polys that fall in the buffer.  
We will use the `gIntersects()` function from the `rgeos` package for this. The function tests if two geometries (let's name them _spgeom1_ and _spgeom2_) have points in common or not. `gIntersects` returns TRUE if _spgeom1_ and _spgeom2_ have at least one point in common.  
Here is where we determine if the census tracts fall within the buffer. In addition to our two sp objects (`ph.buf` and `philly`) we need to provide one mor argument, `byid`. It is a logical vector determining if the function should be applied across ids (TRUE) or the entire object (FALSE) for _spgeom1_ and _spgeom2_. The default setting is FALSE. Since we want to compare every single census tract polygon in our `philly` object we need to set it to TRUE.  
So your command would be    
```
sf.intersects <- gIntersects (birite.buf, sf, byid=TRUE)
```  
Now we can use the values returned by this function to select the polygons. (Note that `gIntersects()` returns a matrix, and we need a vector for the subsetting, so we can simply use `as.vector()` to coerce the matrix into a vector.)  
`sf.selection <- sf[as.vector(sf.intersects),]`

#. Look at it:  
```
plot (sf, border="#aaaaaa")
plot (sf.selection, add=T, col="red") 
plot (sf.buf, add=T, lwd = 2)
```

***


# 3. Combining Rasters and SpatialPolygons

Finally, sometimes we have a SpatialPolygons, and want to know something about the properties within the polygons based on information in a raster dataset. For example, we might have the polygons of electoral districts in Africa, and want to know the average level of light as seen by satellites.

In these situations, we use the `extract` tool, which returns the values of all the raster cells that fall within each polygon. (More specifically, it returns a list of numeric vectors, where the vector in position N corresponds to the raster cell values inside polygon N.) You can then compute on these values as you wish!

## 3.1 Reprojecting Raster data
As with `Spatial*` objects, the first step is to make sure everything has a common projection. 

Raster objects can be reprojected using the `projectRaster` function. However, be aware that reprojecting rasters is not quite as costless as reprojecting vector data. Rasters must also have a regular grid pattern, and since different projections will not necessarily preserve that feature, reprojecting rasters means creating a new grid and computing each value based on overlapping cells from the old grid. Thus it is computationally difficult and can lead to losses of precision. Thus you are probably better off reprojecting your `SpatialPolygon` object rather than your raster. 

## 3.2 The Extract Tool

```{r}
sf.elevation <- raster("RGIS2_Data/sanfrancisconorth.dem")
raster.crs <- CRS(projection(sf.elevation))
sf.reprojected <- spTransform(sf, raster.crs) 
extracted.values <- extract(sf.elevation,sf.reprojected)

# A few example outputs -- 
# low index polygons are in south SF and don't actually have values, so jumping to top. 
extracted.values[174:176]
```

You can get average values using the `sapply()` function:
```{r}
# A subsets of outputs
sapply(extracted.values, mean)[100:130]
```


***

**Answers to Exercise 3**


```{r eval=FALSE}
library(rgeos)

ctr.coords <- data.frame(x = -75.16522, y = 39.95258) # set the coordinates
prj <- CRS("+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs") # set the projection
birite <- SpatialPoints(ctr.coords, proj4string = prj) # create the spatialPoints

birite <- spTransform(birite, sf@proj4string) # reproject!!

birite.buf <- gBuffer(birite, width=6562)  # create buffer around center -- note this projection uses FEET as units, so 2 km is 6562 feet!

sf.intersects <-  gIntersects (birite.buf, sf, byid=TRUE) # determine which census tracts intersect with the buffer

sf.selection <- philly[as.vector(sf.intersects),]

plot (sf, border="#aaaaaa")
plot (sf.selection, add=T, col="red") 
plot (birite.buf, add=T, lwd = 2)

````

![Bi-Rite Selection](images/birite.png)


