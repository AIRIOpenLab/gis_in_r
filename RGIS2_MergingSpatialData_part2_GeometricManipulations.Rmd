---
title: "Merging Spatial Data"
author: "Nick Eubank, building off excellent tutorials by Claudia Engel"
output:
  html_document:
    toc: true
    toc_depth: 4
    theme: spacelab
    mathjax: default
    fig_width: 6
    fig_height: 6
---


```{r knitr_init, echo=FALSE, cache=FALSE, message=FALSE,results="hide"}
library(knitr)
library(rmdformats)
## Global options
options(max.print="75")
opts_chunk$set(echo=TRUE,
	             cache=TRUE,
               prompt=FALSE,
               tidy=TRUE,
               comment=NA,
               message=FALSE,
               warning=FALSE)
opts_knit$set(width=75)

library(rgdal)
library(sp)
library(rgeos)
library(plyr)
library(raster)


setwd("~/dropbox/gis_in_r")

pk.dist <- readOGR(dsn = "RGIS2_data/shapefiles", layer="pk_districts")
strikes <- readOGR(dsn = "RGIS2_data/shapefiles", layer="pk_drone_strikes")
dist.crs <-CRS(proj4string(pk.dist))
strikes.projected <- spTransform(strikes, dist.crs)
pk.pop <- raster("RGIS2_Data/pakp00g")
new.crs <- CRS(projection(pk.pop))
pk.dist.rasterproj <- spTransform(pk.dist, new.crs)


#setwd("E:/Users/neubank/dropbox/gis_in_r")
districts<-readOGR("RGIS2_Data/shapefiles",'congressional_districts')
grants<-readOGR("RGIS2_Data/shapefiles",'federal_grants')
newcrs<-CRS(proj4string(districts))
grants.newproj <- spTransform(grants, newcrs)


```

***

When working with spatial data, one is rarely interested in working with only one source of data. This tutorial will introduce a set of tools for linking vector data with other data sources. It begins by introducing how to link spatial vector data with non-spatial data from in table format, then turns to the problem of linking multiple sources of spatial data through spatial joins and intersects. 

This tutorial uses the `sp`, `rgdal`, and `raster` libraries from the `RGIS1` tutorial. If you have not yet installed those, please revisit that tutorial for directions. In addition, this tutorial will also make use of the `rgeos` library, installation of which is discussed in `part0_setup`. 

***

# 1. RGEOS Overview

The `over` command will cover a remarkable number of situations, but it is really only interesting if two shapes intersect exactly. In practice, however, we are often interested in sligthly more flexible questions: how many cities are *within 10km* of a drone strike? Or how many people live close to a government project? 

When we want to do fancer geometric operations, we use the `rgeos` library. `rgeos` (which stands for "R interface to the *Geometry Engine - Open Source* library") is a set of tools for geometric operations. `GEOS` a huge library, and one that underlies many spatial tools (not just in R). Whenever you're thinking about a geometric operation, `rgeos` is the first place to look.


`rgeos` tools can be broadly divided into three camps. Here some of the most commonly used ones. 

### Calculating Properties

* **gArea**: calculate area of a shape
* **gLength**: calculates length of line / circumference of polygons
* **gDistance**: distance between items

### Making New Shapes

* **gBuffer**: Expand points into circles of given radius
* **gCentroid**: Collapse polygons to their centroids
* **gDifference**, **gUnion**, and **gIntersection**: execute set operations on polygons
* **gUnionCascaded**: dissolves a collection of shapes into a single shape. 
* **gSimplify**: If your polyon is too high a resolution (higher than needed for analysis, and too high for fast processing), reduces the number of vertices while maintaining shape to the best of it's ability. 


### Testing Geometric Relationships

* **gIntersects**: test if shapes intersect. Primarily useful for testing whether two polygons intersect, since this is not something`over` can do. 
* **gContains**: Is one spatial object entirely within another?
* **gIsValid**: Very useful -- make sure your geometries aren't corrupt!


# RGEOS Gotchas

The syntax for these tools varies both across tools and depending on the input types, there are three concepts that come up constantly.

## Gotcha 1: Units
`rgeos` isn't a spatial library -- it just does geometry. It takes x-y coordinates and applies geometric formula. Thus the units will always be the units of the x-y coordinates, which come from your projection. So here, we can check the projection to find our units:

```{r}
proj4string(districts)
```
The units (`+units=m`) are meters. 


## Gotcha 2: byid
`byid` is an option on most `rgeos` commands. If `byid=TRUE`, each observation in a Spatial* object is handled separately; if `byid=FALSE`, a Spatial* object is treated as one big geometry. So if one were working with a `SpatialPolygons` object of US states, when `byid=TRUE`, the analysis would be conducted for each state; if `byid=FALSE`, it would essentially run the analysis against the United States as a whole. 

For example, here is the `gArea` with and without `byid=TRUE`. When true, we get an area for each polygon; when false, we get the area of all polygons combined. 

```{r}
gArea(districts, byid=TRUE)

gArea(districts, byid=FALSE)
```

## Gotcha 3: id

The output of almost all `rgeos` commands will be organized by `id`. For example, with `gArea`, each area has a label: 0, 1, and 2. When working with Spatial*DataFrame objects, `id` will be the rowname for a given observation, just like with tools we've worked with before.

To see an object's `id`s, you can use the combination of the `names` command and the `geometry` command (if you don't use the `geometry` command you'll get column names for objects with associated DataFrames:

```{r}
names(geometry(districts))
```


Things get a little more complicated when `rgeos` creates new polygons using tools like `gBuffer` or `gIntersect`. `rgeos` tends to try and do smart things, but the behavior does vary across tools, so always be careful. 

Here's an example -- let's create buffers (polygons of fixed radius) around our grants the buffers 7km, so we get back polygons for all points within 7km of each project. 

```{r}
proj4string(grants.newproj) # check units!
buffered.grants <- gBuffer(grants.newproj, width=7000, byid=TRUE)
names(geometry(buffered.grants))

plot(districts)
par(new=T)
plot(buffered.grants, col='blue', add=T)
```

Note that points has given rise to a new polygon, many of them overlapping, and they were given simple names based on the names of the points that generated them. However, if we want a polygon of points within 7km of *any* grant, we can pass byid=FALSE`. Now we have one polygon (named `buffer`) instead of 5. 

```{r}
buffered.grants <- gBuffer(grants.newproj, width=7000, byid=FALSE)
names(geometry(buffered.grants))

plot(districts)
par(new=T)
plot(buffered.grants, col='blue', add=T)
```


# Unusual Tools: Set operations

`rgeos` can also do set operations on polygons, like returning areas in which different polygons coincide, don't coincide.

This can be useful for lots of things. For example, the figure of grant buffers above looks a little odd because the buffered polygons spread into the ocean. We can fix this by "clipping" the buffered polygons using `gIntersection` -- essentially keeping only the part of the buffer that also coincides with districts.

```{r}
intersection <- gIntersection(buffered.grants, districts, byid=TRUE)
plot(districts)
par(new=T)
plot(intersection, col='blue', add=T)
par(new=F)
```

Interestingly, note that while `buffered.grants` was previously one feature, because we passed `byid=TRUE`, the intersection with the districts executed the intersection for each congressional district, creating three distinct polygons.

```{r}
intersection
```

Moreover, the `id`s assigned to these polygons are just concatenations of the `id`s of `buffered.grants` and `districts`, a pattern that would hold even if `buffered.grants` had fancier names:
```{r}
names(geometry(buffered.grants))
names(geometry(districts))
names(geometry(intersection))
```

# Last Word: `byid` Issues

One thing to be aware of is that `rgeos` sometimes struggles when `byid` is set to `FALSE`. For example, if we want to clip our buffered polygon by the extent of all electoral districts -- but not add cuts where the polygon crosses the lines between districts -- one might try the following code:

The following code:
```{r, eval=FALSE}
gIntersection(buffered.grants, districts, byid=FALSE)
```

But oddly, this generates the error:
`Error in RGEOSBinTopoFunc(spgeom1, spgeom2, byid, id, drop_lower_td, "rgeos_intersection") :` 
`  TopologyException: no outgoing dirEdge found at 570113.57942913717 4148852.3204373871`

This kind of problem will come up from time to time -- my general solution is to first dissolve the layer we want to consider as one polygon into a single polygon using `gUnionCascaded`, *then* execute the second command:

```{r}
merged.districts <- gUnionCascaded(districts)
plot(merged.districts)

intersection2 <- gIntersection(buffered.grants, merged.districts, byid=FALSE)
intersection2
plot(districts)
par(new=T)
plot(intersection2, col='blue', add=T)
par(new=F)
```
Now the intersection is only one part!


## Exercise 1

Let's try and figure out what percentage of residents of Pakistans Federally Administered Tribal Areas (FATA, the regions with the most drone strikes) live within 7km of a drone strike. 

#. Subset the pk.dist data for the Province of Fata.

#. Create a buffer of 5km around each drone strike with the `gBuffer` command. 

#. Intersect this with Districts using `gUnion`. 

#. Measure the share of each district within 1km of a drone strike using the `gArea` command for each district, and for the buffered strikes in each district. 

#. In the last exercise, we measured strikes per capita -- did this number seem high or low? Does this measure of proximity to strikes seem different?

#. Run this analysis just for strikes in 2012. If you've used ArcGIS before, how would you re-run this analysis in ArcGIS? Would it be easier or harder?




***

**Answers to Exercise 1**


```{r, eval=FALSE}
pk.dist <- readOGR(dsn = "RGIS2_data/shapefiles", layer="pk_districts")
strikes.wrongproj <- readOGR(dsn = "RGIS2_data/shapefiles", layer="pk_drone_strikes")
dist.crs <-CRS(proj4string(pk.dist))
strikes <- spTransform(strikes.wrongproj, dist.crs)

# Subset to Fata
fata <- pk.dist[pk.dist$PROVINCE=='Fata',]
fata$OBJECTID <- NULL # Drop column called objectid -- came from shapefile. Just confuses things. 

# Buffer strikes
proj4string(strikes) # Check projection units
strike.buffer <- gBuffer(strikes, width=7000, byid=FALSE, id="")
strike.buffer.inter <- gIntersection(strike.buffer, fata, byid=TRUE)

# Now to merge back in with Districts based on row numbers
strike.areas <- as.data.frame(gArea(strike.buffer.inter, byid=TRUE))
colnames(strike.areas) <- "buffer_area"
strike.areas$rownumbers <- as.numeric(rownames(strike.areas))
fata@data$rownumbers <- as.numeric(rownames(fata@data))

fata@data <- join(fata@data, strike.areas, by="rownumbers", type="left")

# Calculate share of area within strike buffer
fata@data[is.na(fata@data$buffer_area),"buffer_area"]<-0
fata@data$share_covered <- fata@data$buffer_area / fata@data$Shape_Area
fata@data$share_covered

# Only for 2012: add: 
#       strikes <- strikes[strikes$year == 2012,]
# To start of code and just rerun!

```

